const VERSION = "1.0.0";

const assets = [
  "/",
  "/offline.html",
  "/manifest.webmanifest",
  "/1.jpg",
  "/2.jpg",
  "/3.jpg",
  "/4.jpg",
  "/5.jpg",
  "/d1.png",
  "/d2.png",
  "/d3.png",
  "/mascot-192.png",
  "/mascot-512.png",
  "/boy.svg",
  "/es.svg",
  "/finish.svg",
  "/fr.svg",
  "/girl.svg",
  "/heart.svg",
  "/hero.svg",
  "/hr.svg",
  "/it.svg",
  "/jp.svg",
  "/leaderboard.svg",
  "/learn.svg",
  "/man.svg",
  "/mascot_bad.svg",
  "/mascot_sad.svg",
  "/mascot.svg",
  "/points.svg",
  "/quests.svg",
  "/robot.svg",
  "/shop.svg",
  "/unlimited.svg",
  "/woman.svg",
  "/zombie.svg",
  "/correct.wav",
  "/es_boy.mp3",
  "/es_girl.mp3",
  "/es_man.mp3",
  "/es_robot.mp3",
  "/es_woman.mp3",
  "/es_zombie.mp3",
  "/fr_boy.mp3",
  "/fr_girl.mp3",
  "/fr_man.mp3",
  "/fr_robot.mp3",
  "/fr_woman.mp3",
  "/fr_zombie.mp3",
  "/hr_boy.mp3",
  "/hr_girl.mp3",
  "/hr_man.mp3",
  "/hr_robot.mp3",
  "/hr_woman.mp3",
  "/hr_zombie.mp3",
  "/it_boy.mp3",
  "/it_girl.mp3",
  "/it_man.mp3",
  "/it_robot.mp3",
  "/it_woman.mp3",
  "/it_zombie.mp3",
  "/jp_boy.mp3",
  "/jp_girl.mp3",
  "/jp_man.mp3",
  "/jp_robot.mp3",
  "/jp_woman.mp3",
  "/jp_zombie.mp3",
  "/incorrect.wav",
  "/finish.mp3",
  "/og-poster.jpg",
];

const assetsCacheName = "lingo" + VERSION;

self.addEventListener("install", (event) => {
  event.waitUntil(
    (async () => {
      const cache = await caches.open(assetsCacheName);
      await Promise.allSettled(assets.map((url) => cache.add(url)));

      self.skipWaiting();
    })()
  );
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    (async () => {
      // Remove old caches (assets)
      const keys = await caches.keys();
      await Promise.allSettled(
        keys
          .filter((key) => key !== assetsCacheName)
          .map((key) => caches.delete(key))
      );
      await self.clients.claim();
    })()
  );
});

self.addEventListener("message", (event) => {
  // We want to cache missing assets (if there is any) whenever user loads our app.
  if (event.data?.type === "CACHE-MISSING-ASSETS") {
    (async () => {
      try {
        const cache = await caches.open(assetsCacheName);
        const matches = await Promise.all(
          assets.map((asset) => cache.match(asset))
        );

        const missingAssets = assets.filter((_, i) => !matches[i]);

        if (missingAssets.length) {
          await Promise.allSettled(missingAssets.map((url) => cache.add(url)));
        }
      } catch (err) {
        console.error("Error caching missing assets:", err);
      }
    })();
  }
});

self.addEventListener("fetch", (event) => {
  // we don't want to cache any method beside GET...
  if (event.request.method !== "GET") {
    event.respondWith(networkOnly(event.request));
    return;
  }

  const eventUrl = new URL(event.request.url);

  // Next.js related things... (i don't even know what they are, i just know they ruin my app)
  if (eventUrl.searchParams.has("_rsc")) {
    event.respondWith(networkOnly(event.request));
    return;
  }

  // HTML files, if the requested page is in the cache we respond with it, if not, we respond with the offline page...
  if (
    event.request.mode === "navigate" ||
    event.request.headers.get("accept")?.includes("text/html")
  ) {
    if (eventUrl.pathname.startsWith("/")) {
      event.respondWith(
        cacheOnly(event.request, assetsCacheName, /*returnOffline= */ true)
      );
      return;
    }

    event.respondWith(
      networkOnly(event.request, null, /*returnOffline= */ true)
    );
    return;
  }

  // static files
  if (eventUrl.host === self.location.host) {
    // static files generated by Next.js
    // (Fonts)
    if (eventUrl.pathname.startsWith("/_next/static/media")) {
      event.respondWith(cacheOnly(event.request, assetsCacheName));
      return;
    }

    // (CSS, JS)
    if (eventUrl.pathname.startsWith("/_next/static")) {
      event.respondWith(staleWhileRevalidate(event.request, assetsCacheName));
      return;
    }

    // images generated by Next.js
    if (eventUrl.pathname.startsWith("/_next/image")) {
      event.respondWith(cacheOnly(event.request, assetsCacheName));
      return;
    }

    // cached files in assets
    if (assets.includes(eventUrl.pathname)) {
      event.respondWith(cacheOnly(event.request, assetsCacheName));
      return;
    }
  }

  // other requests...
  event.respondWith(networkOnly(event.request));
});

async function findCachedData(req, cacheName, returnOffline = false) {
  // if the request was for a html page, we ignore search params...
  const cacheProps = returnOffline ? { ignoreSearch: true } : undefined;
  const cache = await caches.open(cacheName);
  const cachedResponse = await cache.match(req, cacheProps);

  return cachedResponse;
}

async function cacheOnly(req, cacheName, returnOffline = false) {
  const cachedResponse = await findCachedData(req, cacheName, returnOffline);

  if (cachedResponse) {
    return cachedResponse.clone();
  }

  return networkOnly(req, cache, returnOffline);
}

async function staleWhileRevalidate(req, cacheName, returnOffline = false) {
  const cachedResponse = await findCachedData(req, cacheName, returnOffline);
  const fetchRes = await networkOnly(req, cache, returnOffline);

  return cachedResponse || fetchRes;
}

async function networkOnly(req, cache = null, returnOffline = false) {
  return fetch(req)
    .then(async (networkRes) => {
      if (cache && networkRes.ok) await cache.put(req, networkRes.clone());
      return networkRes;
    })
    .catch(async () => {
      const errMsg =
        "Network error and no cached data available. see the browser's console for more information";
      let errResponse = errMsg;

      if (returnOffline) {
        const assetsCache = await caches.open(assetsCacheName);
        const offlinePage = await assetsCache.match("/offline.html");

        if (offlinePage) return offlinePage;

        // if we couldn't find the offline.html, we return a simple html page.
        errResponse = `<!DOCTYPE html><html lang="en"><head><meta name="color-scheme"content="only light"/><meta name="viewport"content="width=device-width,initial-scale=1,maximum-scale=5,viewport-fit=cover"/><title>Network error and no cached data</title></head><body style='background:white;display:flex;justify-content:center;align-items:center;padding-block:1rem;font-family:Arial,Helvetica,sans-serif;'><h1 style='color:black;'>${errMsg}</h1></body></html>`;
      }

      return new Response(errResponse, {
        status: 503,
        statusText: "Service Unavailable.",
        headers: { "Content-Type": returnOffline ? "text/html" : "text/plain" },
      });
    });
}
